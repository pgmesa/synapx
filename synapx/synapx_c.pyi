"""
pybind11 plugin for Tensor class
"""
from __future__ import annotations
import typing
__all__ = ['DataType', 'TensorFloat32', 'TensorInt32', 'TensorUInt8']
class DataType:
    """
    Members:
    
      UINT8
    
      INT32
    
      FLOAT32
    """
    FLOAT32: typing.ClassVar[DataType]  # value = <DataType.FLOAT32: 2>
    INT32: typing.ClassVar[DataType]  # value = <DataType.INT32: 1>
    UINT8: typing.ClassVar[DataType]  # value = <DataType.UINT8: 0>
    __members__: typing.ClassVar[dict[str, DataType]]  # value = {'UINT8': <DataType.UINT8: 0>, 'INT32': <DataType.INT32: 1>, 'FLOAT32': <DataType.FLOAT32: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class TensorFloat32:
    @staticmethod
    def empty(arg0: list[int]) -> TensorFloat32:
        ...
    @staticmethod
    def full(arg0: list[int], arg1: float) -> TensorFloat32:
        ...
    @staticmethod
    def matmul(arg0: TensorFloat32, arg1: TensorFloat32) -> TensorFloat32:
        ...
    @staticmethod
    def ones(arg0: list[int]) -> TensorFloat32:
        ...
    @staticmethod
    def zeros(arg0: list[int]) -> TensorFloat32:
        ...
    @typing.overload
    def __add__(self, arg0: TensorFloat32) -> TensorFloat32:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> TensorFloat32:
        ...
    @typing.overload
    def __iadd__(self, arg0: TensorFloat32) -> TensorFloat32:
        ...
    @typing.overload
    def __iadd__(self, arg0: float) -> TensorFloat32:
        ...
    @typing.overload
    def __imul__(self, arg0: TensorFloat32) -> TensorFloat32:
        ...
    @typing.overload
    def __imul__(self, arg0: float) -> TensorFloat32:
        ...
    def __init__(self) -> None:
        ...
    def __matmul__(self, arg0: TensorFloat32) -> TensorFloat32:
        ...
    @typing.overload
    def __mul__(self, arg0: TensorFloat32) -> TensorFloat32:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> TensorFloat32:
        ...
    def __repr__(self) -> str:
        ...
    def broadcast_to(self, arg0: list[int]) -> TensorFloat32:
        ...
    def expand(self, arg0: list[int]) -> TensorFloat32:
        ...
    def squeeze(self, arg0: list[int]) -> TensorFloat32:
        ...
    def unsqueeze(self, arg0: list[int]) -> TensorFloat32:
        ...
    def view(self, arg0: list[int]) -> TensorFloat32:
        ...
    @property
    def dtype(self) -> DataType:
        ...
    @property
    def ndim(self) -> int:
        ...
    @property
    def numel(self) -> int:
        ...
    @property
    def shape(self) -> list[int]:
        ...
    @property
    def strides(self) -> list[int]:
        ...
class TensorInt32:
    @staticmethod
    def empty(arg0: list[int]) -> TensorInt32:
        ...
    @staticmethod
    def full(arg0: list[int], arg1: float) -> TensorInt32:
        ...
    @staticmethod
    def matmul(arg0: TensorInt32, arg1: TensorInt32) -> TensorInt32:
        ...
    @staticmethod
    def ones(arg0: list[int]) -> TensorInt32:
        ...
    @staticmethod
    def zeros(arg0: list[int]) -> TensorInt32:
        ...
    @typing.overload
    def __add__(self, arg0: TensorInt32) -> TensorInt32:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> TensorInt32:
        ...
    @typing.overload
    def __iadd__(self, arg0: TensorInt32) -> TensorInt32:
        ...
    @typing.overload
    def __iadd__(self, arg0: float) -> TensorInt32:
        ...
    @typing.overload
    def __imul__(self, arg0: TensorInt32) -> TensorInt32:
        ...
    @typing.overload
    def __imul__(self, arg0: float) -> TensorInt32:
        ...
    def __init__(self) -> None:
        ...
    def __matmul__(self, arg0: TensorInt32) -> TensorInt32:
        ...
    @typing.overload
    def __mul__(self, arg0: TensorInt32) -> TensorInt32:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> TensorInt32:
        ...
    def __repr__(self) -> str:
        ...
    def broadcast_to(self, arg0: list[int]) -> TensorInt32:
        ...
    def expand(self, arg0: list[int]) -> TensorInt32:
        ...
    def squeeze(self, arg0: list[int]) -> TensorInt32:
        ...
    def unsqueeze(self, arg0: list[int]) -> TensorInt32:
        ...
    def view(self, arg0: list[int]) -> TensorInt32:
        ...
    @property
    def dtype(self) -> DataType:
        ...
    @property
    def ndim(self) -> int:
        ...
    @property
    def numel(self) -> int:
        ...
    @property
    def shape(self) -> list[int]:
        ...
    @property
    def strides(self) -> list[int]:
        ...
class TensorUInt8:
    @staticmethod
    def empty(arg0: list[int]) -> TensorUInt8:
        ...
    @staticmethod
    def full(arg0: list[int], arg1: float) -> TensorUInt8:
        ...
    @staticmethod
    def matmul(arg0: TensorUInt8, arg1: TensorUInt8) -> TensorUInt8:
        ...
    @staticmethod
    def ones(arg0: list[int]) -> TensorUInt8:
        ...
    @staticmethod
    def zeros(arg0: list[int]) -> TensorUInt8:
        ...
    @typing.overload
    def __add__(self, arg0: TensorUInt8) -> TensorUInt8:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> TensorUInt8:
        ...
    @typing.overload
    def __iadd__(self, arg0: TensorUInt8) -> TensorUInt8:
        ...
    @typing.overload
    def __iadd__(self, arg0: float) -> TensorUInt8:
        ...
    @typing.overload
    def __imul__(self, arg0: TensorUInt8) -> TensorUInt8:
        ...
    @typing.overload
    def __imul__(self, arg0: float) -> TensorUInt8:
        ...
    def __init__(self) -> None:
        ...
    def __matmul__(self, arg0: TensorUInt8) -> TensorUInt8:
        ...
    @typing.overload
    def __mul__(self, arg0: TensorUInt8) -> TensorUInt8:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> TensorUInt8:
        ...
    def __repr__(self) -> str:
        ...
    def broadcast_to(self, arg0: list[int]) -> TensorUInt8:
        ...
    def expand(self, arg0: list[int]) -> TensorUInt8:
        ...
    def squeeze(self, arg0: list[int]) -> TensorUInt8:
        ...
    def unsqueeze(self, arg0: list[int]) -> TensorUInt8:
        ...
    def view(self, arg0: list[int]) -> TensorUInt8:
        ...
    @property
    def dtype(self) -> DataType:
        ...
    @property
    def ndim(self) -> int:
        ...
    @property
    def numel(self) -> int:
        ...
    @property
    def shape(self) -> list[int]:
        ...
    @property
    def strides(self) -> list[int]:
        ...
